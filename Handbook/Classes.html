<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>类 | TypeScript 中文文档</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="https://vuepress-theme-reco.recoluan.com/favicon.ico">
    <meta name="description" content="TypeScript 官方文档中文翻译">
    
    <link rel="preload" href="/Vuepress-TypeScriptDoc/assets/css/0.styles.09ce7fc6.css" as="style"><link rel="preload" href="/Vuepress-TypeScriptDoc/assets/js/app.9c3a9755.js" as="script"><link rel="preload" href="/Vuepress-TypeScriptDoc/assets/js/3.cc39fa8f.js" as="script"><link rel="preload" href="/Vuepress-TypeScriptDoc/assets/js/1.145ed21b.js" as="script"><link rel="preload" href="/Vuepress-TypeScriptDoc/assets/js/10.df955495.js" as="script"><link rel="prefetch" href="/Vuepress-TypeScriptDoc/assets/js/11.236ee6b2.js"><link rel="prefetch" href="/Vuepress-TypeScriptDoc/assets/js/12.f4a27505.js"><link rel="prefetch" href="/Vuepress-TypeScriptDoc/assets/js/13.fe395da4.js"><link rel="prefetch" href="/Vuepress-TypeScriptDoc/assets/js/14.a3032c2e.js"><link rel="prefetch" href="/Vuepress-TypeScriptDoc/assets/js/15.383e616a.js"><link rel="prefetch" href="/Vuepress-TypeScriptDoc/assets/js/16.f582a7d3.js"><link rel="prefetch" href="/Vuepress-TypeScriptDoc/assets/js/17.a837ec11.js"><link rel="prefetch" href="/Vuepress-TypeScriptDoc/assets/js/18.a9b10cb7.js"><link rel="prefetch" href="/Vuepress-TypeScriptDoc/assets/js/19.2ce593bf.js"><link rel="prefetch" href="/Vuepress-TypeScriptDoc/assets/js/20.7e1de8e0.js"><link rel="prefetch" href="/Vuepress-TypeScriptDoc/assets/js/21.4509449a.js"><link rel="prefetch" href="/Vuepress-TypeScriptDoc/assets/js/22.39796520.js"><link rel="prefetch" href="/Vuepress-TypeScriptDoc/assets/js/23.28660fb6.js"><link rel="prefetch" href="/Vuepress-TypeScriptDoc/assets/js/24.d9d6cea1.js"><link rel="prefetch" href="/Vuepress-TypeScriptDoc/assets/js/25.0e669f06.js"><link rel="prefetch" href="/Vuepress-TypeScriptDoc/assets/js/26.b4a06445.js"><link rel="prefetch" href="/Vuepress-TypeScriptDoc/assets/js/4.38cfa428.js"><link rel="prefetch" href="/Vuepress-TypeScriptDoc/assets/js/5.810c2aa5.js"><link rel="prefetch" href="/Vuepress-TypeScriptDoc/assets/js/6.c1f5de78.js"><link rel="prefetch" href="/Vuepress-TypeScriptDoc/assets/js/7.18d47045.js"><link rel="prefetch" href="/Vuepress-TypeScriptDoc/assets/js/8.a3953fde.js"><link rel="prefetch" href="/Vuepress-TypeScriptDoc/assets/js/9.450893a2.js">
    <link rel="stylesheet" href="/Vuepress-TypeScriptDoc/assets/css/0.styles.09ce7fc6.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-1aefc0b4><div data-v-1aefc0b4><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-1aefc0b4 data-v-1aefc0b4><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-25ba6db2 data-v-1aefc0b4 data-v-1aefc0b4><h3 class="title" data-v-25ba6db2 data-v-25ba6db2>TypeScript 中文文档</h3> <p class="description" data-v-25ba6db2 data-v-25ba6db2>TypeScript 官方文档中文翻译</p> <label id="box" class="inputBox" data-v-25ba6db2 data-v-25ba6db2><input type="password" value="" data-v-25ba6db2> <span data-v-25ba6db2>Konck! Knock!</span> <button data-v-25ba6db2>OK</button></label> <div class="footer" data-v-25ba6db2 data-v-25ba6db2><span data-v-25ba6db2><i class="iconfont reco-theme" data-v-25ba6db2></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-25ba6db2>vuePress-theme-reco</a></span> <span data-v-25ba6db2><i class="iconfont reco-copyright" data-v-25ba6db2></i> <a data-v-25ba6db2><!---->
            
          <!---->
          2021
        </a></span></div></div> <div class="hide" data-v-1aefc0b4><header class="navbar" data-v-1aefc0b4><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/Vuepress-TypeScriptDoc/" class="home-link router-link-active"><!----> <span class="site-name">TypeScript 中文文档</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/Vuepress-TypeScriptDoc/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      关于我
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/Chorer" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://chorer.github.io/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  个人博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/888061127569902" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://segmentfault.com/u/chor" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  SegmentFault
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-1aefc0b4></div> <aside class="sidebar" data-v-1aefc0b4><div class="personal-info-wrapper" data-v-39576ba9 data-v-1aefc0b4><!----> <!----> <div class="num" data-v-39576ba9><div data-v-39576ba9><h3 data-v-39576ba9>17</h3> <h6 data-v-39576ba9>Articles</h6></div> <div data-v-39576ba9><h3 data-v-39576ba9>0</h3> <h6 data-v-39576ba9>Tags</h6></div></div> <ul class="social-links" data-v-39576ba9></ul> <hr data-v-39576ba9></div> <nav class="nav-links"><div class="nav-item"><a href="/Vuepress-TypeScriptDoc/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      关于我
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/Chorer" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://chorer.github.io/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  个人博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/888061127569902" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://segmentfault.com/u/chor" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  SegmentFault
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/Vuepress-TypeScriptDoc/" class="sidebar-heading clickable router-link-active"><span>欢迎</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/Vuepress-TypeScriptDoc/" aria-current="page" class="sidebar-link">关于</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/Vuepress-TypeScriptDoc/Handbook/TheTypeScriptHandbook" class="sidebar-heading clickable open"><span>手册</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/Vuepress-TypeScriptDoc/Handbook/TheTypeScriptHandbook.html" class="sidebar-link">TypeScript 手册</a></li><li><a href="/Vuepress-TypeScriptDoc/Handbook/TheBasics.html" class="sidebar-link">基础</a></li><li><a href="/Vuepress-TypeScriptDoc/Handbook/EverydayTypes.html" class="sidebar-link">普通类型</a></li><li><a href="/Vuepress-TypeScriptDoc/Handbook/Narrowing.html" class="sidebar-link">类型收缩</a></li><li><a href="/Vuepress-TypeScriptDoc/Handbook/MoreOnFunctions.html" class="sidebar-link">关于函数</a></li><li><a href="/Vuepress-TypeScriptDoc/Handbook/ObjectTypes.html" class="sidebar-link">对象类型</a></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/Vuepress-TypeScriptDoc/Handbook/TypeManipulation/CreatingTypesFromTypes" class="sidebar-heading clickable"><span>类型操控</span> <span class="arrow right"></span></a> <!----></section></li><li><a href="/Vuepress-TypeScriptDoc/Handbook/Classes.html" aria-current="page" class="active sidebar-link">类</a></li><li><a href="/Vuepress-TypeScriptDoc/Handbook/Modules.html" class="sidebar-link">模块</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-25ba6db2 data-v-1aefc0b4><h3 class="title" data-v-25ba6db2 data-v-25ba6db2>类</h3> <!----> <label id="box" class="inputBox" data-v-25ba6db2 data-v-25ba6db2><input type="password" value="" data-v-25ba6db2> <span data-v-25ba6db2>Konck! Knock!</span> <button data-v-25ba6db2>OK</button></label> <div class="footer" data-v-25ba6db2 data-v-25ba6db2><span data-v-25ba6db2><i class="iconfont reco-theme" data-v-25ba6db2></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-25ba6db2>vuePress-theme-reco</a></span> <span data-v-25ba6db2><i class="iconfont reco-copyright" data-v-25ba6db2></i> <a data-v-25ba6db2><!---->
            
          <!---->
          2021
        </a></span></div></div> <div data-v-1aefc0b4><main class="page"><section><div class="page-title"><h1 class="title">类</h1> <div data-v-f875f3fc><!----> <!----> <!----> <!----></div></div> <div class="theme-reco-content content__default"><blockquote><p>背景导读：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener noreferrer">类（MDN）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>TypeScript 为 ES2015 引入的 <code>class</code> 关键字提供了全面的支持。</p> <p>就像其它的 JavaScript 语言特性一样，TypeScript 也为类提供了类型注解和其它语法，以帮助开发者表示类和其它类型之间的关系。</p> <h2 id="类成员"><a href="#类成员" class="header-anchor">#</a> 类成员</h2> <p>这是一个最基本的类 —— 它是空的：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p>这个类目前没有什么用，所以我们给它添加一些成员吧。</p> <h3 id="字段"><a href="#字段" class="header-anchor">#</a> 字段</h3> <p>声明字段相当于是给类添加了一个公共的、可写的属性：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
    x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
    y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> pt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
pt<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
pt<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre></div><p>和其它特性一样，这里的类型注解也是可选的，但如果没有指定类型，则会隐式采用 <code>any</code> 类型。</p> <p>字段也可以进行初始化，初始化过程会在类实例化的时候自动进行：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
  x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">const</span> pt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 打印 0, 0</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>pt<span class="token punctuation">.</span>x<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>pt<span class="token punctuation">.</span>y<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>就像使用 <code>const</code>、<code>let</code> 和 <code>var</code> 一样，类属性的初始化语句也会被用于进行类型推断：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> pt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
pt<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token string">&quot;0&quot;</span><span class="token punctuation">;</span>
<span class="token comment">// Type 'string' is not assignable to type 'number'.</span>
</code></pre></div><h4 id="strictpropertyinitialization"><a href="#strictpropertyinitialization" class="header-anchor">#</a> --strictPropertyInitialization</h4> <p>配置项 <a href="https://www.typescriptlang.org/tsconfig#strictPropertyInitialization" target="_blank" rel="noopener noreferrer">strictPropertyInitialization<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 用于控制类的字段是否需要在构造器中进行初始化。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">BadGreeter</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
    <span class="token operator">^</span>
<span class="token comment">// Property 'name' has no initializer and is not definitely assigned in the constructor.</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">GoodGreeter</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
 
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>    
</code></pre></div><p>注意，字段需要在构造器自身内部进行初始化。TypeScript 不会分析在构造器中调用的方法以检测初始化语句，因为派生类可能会重写这些方法，导致初始化成员失败。</p> <p>如果你坚持要使用除了构造器之外的方法（比如使用一个外部库填充类的内容）去初始化一个字段，那么你可以使用确定赋值断言运算符 <code>！</code>：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">OKGreeter</span> <span class="token punctuation">{</span>
  <span class="token comment">// 没有初始化，但不会报错</span>
  name<span class="token operator">!</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="readonly"><a href="#readonly" class="header-anchor">#</a> <code>readonly</code></h3> <p>字段可以加上 <code>readonly</code> 修饰符作为前缀，以防止在构造器外面对字段进行赋值。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">Greeter</span> <span class="token punctuation">{</span>
  <span class="token keyword">readonly</span> name<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">&quot;world&quot;</span><span class="token punctuation">;</span>
 
  <span class="token function">constructor</span><span class="token punctuation">(</span>otherName<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>otherName <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> otherName<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
 
  <span class="token function">err</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;not ok&quot;</span><span class="token punctuation">;</span>
      	   <span class="token operator">^</span>
<span class="token comment">// Cannot assign to 'name' because it is a read-only property.</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> g <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Greeter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
g<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;also not ok&quot;</span><span class="token punctuation">;</span>
    <span class="token operator">^</span>
<span class="token comment">// Cannot assign to 'name' because it is a read-only property.</span>
</code></pre></div><h3 id="构造器"><a href="#构造器" class="header-anchor">#</a> 构造器</h3> <p>类的构造器和函数很像，你可以给它的参数添加类型注解，可以使用参数默认值或者是函数重载：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
    x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
    y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
    <span class="token comment">// 使用了参数默认值的正常签名</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span>x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
  <span class="token comment">// 使用重载</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>s<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>xs<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> y<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// TBD</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>类的构造器签名和函数签名只有一点区别：</p> <ul><li>构造器不能使用类型参数 —— 类型参数属于类声明的部分，稍后我们会进行学习</li> <li>构造器不能给返回值添加类型注解 —— 它返回的类型始终是类实例的类型</li></ul> <h4 id="super-调用"><a href="#super-调用" class="header-anchor">#</a> <code>super</code> 调用</h4> <p>和 JavaScript 一样，如果你有一个基类和一个派生类，那么在派生类中使用 <code>this.</code> 访问类成员之前，必须先在构造器中调用 <code>super();</code>：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
  k <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ES5 下打印出错误的值，ES6 下报错</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
                  <span class="token operator">^</span>
<span class="token comment">// 'super' must be called before accessing 'this' in the constructor of a derived class.</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在 JavaScript 中，忘记调用 <code>super</code> 是一个常见的错误，但 TypeScript 会在必要时给你提醒。</p> <h3 id="方法"><a href="#方法" class="header-anchor">#</a> 方法</h3> <p>类的属性可能是一个函数，这时候我们称其为方法。方法和函数以及构造器一样，也可以使用各种类型注解：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
  x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  y <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
 
  <span class="token function">scale</span><span class="token punctuation">(</span>n<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">*=</span> n<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">*=</span> n<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>除了标准的类型注解之外，TypeScript 没有给方法添加什么新的东西。</p> <p>注意，在方法体中，必须通过 <code>this.</code> 才能访问到类的字段和其它方法。在方法体中使用不合规的名字，将会被视为是在访问邻近作用域中的变量：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> x<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 
<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">{</span>
  x<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>
 
  <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 下面这句是在试图修改第一行的 x，而不是类的属性</span>
    x <span class="token operator">=</span> <span class="token string">&quot;world&quot;</span><span class="token punctuation">;</span>
    <span class="token operator">^</span>  
<span class="token comment">// Type 'string' is not assignable to type 'number'.</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="getters-setters"><a href="#getters-setters" class="header-anchor">#</a> Getters/Setters</h3> <p>类也可以有访问器：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">{</span>
    _length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">get</span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_length<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">set</span> <span class="token function">length</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>_length <span class="token operator">=</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>注意：在 JavaScript 中，一个没有额外逻辑的 get/set 对是没有什么作用的。如果在执行 get/set 操作的时候不需要添加额外的逻辑，那么只需要将字段暴露为公共字段即可。</p></blockquote> <p>对于访问器，TypeScript 有一些特殊的推断规则：</p> <ul><li>如果 <code>get</code> 存在而 <code>set</code> 不存在，那么属性会自动成为只读属性</li> <li>如果没有指定 setter 参数的类型，那么会基于 getter 返回值的类型去推断参数类型</li> <li>getter 和 setter 必须具备相同的<a href="#%E6%88%90%E5%91%98%E5%8F%AF%E8%A7%81%E6%80%A7">成员可见性</a>。</li></ul> <p>从 <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-3/" target="_blank" rel="noopener noreferrer">TypeScript 4.3<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 开始，访问器的 getter 和 setter 可以使用不同的类型。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">Thing</span> <span class="token punctuation">{</span>
  _size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 
  <span class="token keyword">get</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_size<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
 
  <span class="token keyword">set</span> <span class="token function">size</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">boolean</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token comment">// 不允许使用 NaN、Infinity 等</span>
 
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Number<span class="token punctuation">.</span><span class="token function">isFinite</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>_size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token keyword">this</span><span class="token punctuation">.</span>_size <span class="token operator">=</span> num<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="索引签名"><a href="#索引签名" class="header-anchor">#</a> 索引签名</h3> <p>类可以声明索引签名，其工作方式和<a href="https://www.typescriptlang.org/docs/handbook/2/objects.html#index-signatures" target="_blank" rel="noopener noreferrer">其它对象类型的索引签名<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一样：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span>s<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">boolean</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">check</span><span class="token punctuation">(</span>s<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token keyword">as</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>因为索引签名类型也需要捕获方法的类型，所以要有效地使用这些类型并不容易。通常情况下，最好将索引数据存储在另一个位置，而不是类实例本身。</p> <h2 id="类继承"><a href="#类继承" class="header-anchor">#</a> 类继承</h2> <p>和其它面向对象语言一样，JavaScript 中的类可以继承自基类。</p> <h3 id="implements-子句"><a href="#implements-子句" class="header-anchor">#</a> <code>implements</code> 子句</h3> <p>你可以使用一个 <code>implements</code> 子句去检查类是否符合某个特定的接口。如果类没有正确地实现这个接口，那么就会抛出一个错误：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">Pingable</span> <span class="token punctuation">{</span>
  <span class="token function">ping</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">class</span> <span class="token class-name">Sonar</span> <span class="token keyword">implements</span> <span class="token class-name">Pingable</span> <span class="token punctuation">{</span>
  <span class="token function">ping</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;ping!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">class</span> <span class="token class-name">Ball</span> <span class="token keyword">implements</span> <span class="token class-name">Pingable</span> <span class="token punctuation">{</span>
        <span class="token operator">^</span>
<span class="token comment">/*
Class 'Ball' incorrectly implements interface 'Pingable'.
  Property 'ping' is missing in type 'Ball' but required in type 'Pingable'.
*/</span>  
  <span class="token function">pong</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;pong!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>类可以实现多个接口，比如 <code>class C implements A,B {</code>。</p> <h4 id="注意事项"><a href="#注意事项" class="header-anchor">#</a> 注意事项</h4> <p>有个要点需要理解，那就是 <code>implements</code> 子句只是用于检查类是否可以被视为某个接口类型，它完全不会改变类的类型或者它的方法。常见的错误是认为 <code>implements</code> 子句会改变类的类型 —— 实际上是不会的！</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">Checkable</span> <span class="token punctuation">{</span>
  <span class="token function">check</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">class</span> <span class="token class-name">NameChecker</span> <span class="token keyword">implements</span> <span class="token class-name">Checkable</span> <span class="token punctuation">{</span>
  <span class="token function">check</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">^</span>
<span class="token comment">//Parameter 's' implicitly has an 'any' type.</span>
    <span class="token comment">// 注意这里不会抛出错误</span>
    <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">toLowercse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">&quot;ok&quot;</span><span class="token punctuation">;</span>
                 <span class="token operator">^</span>
              <span class="token comment">// any</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在这个例子中，我们可能会认为 <code>s</code> 的类型会受到接口中 <code>check</code> 的 <code>name: string</code> 参数的影响。但实际上不会 —— <code>implements</code> 子句不会对类内容体的检查以及类型推断产生任何影响。</p> <p>同理，实现一个带有可选属性的接口，并不会创建该属性：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token punctuation">{</span>
  x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  y<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token punctuation">{</span>
  x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">C</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
c<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token operator">^</span>
<span class="token comment">// Property 'y' does not exist on type 'C'.</span>
</code></pre></div><h3 id="extends-子句"><a href="#extends-子句" class="header-anchor">#</a> <code>extends</code> 子句</h3> <p>类可以继承自某个基类。派生类拥有基类的所有属性和方法，同时也可以定义额外的成员。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
  <span class="token function">move</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Moving along!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
  <span class="token function">woof</span><span class="token punctuation">(</span>times<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> times<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;woof!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">const</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 基类方法</span>
d<span class="token punctuation">.</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 派生类方法</span>
d<span class="token punctuation">.</span><span class="token function">woof</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="重写方法"><a href="#重写方法" class="header-anchor">#</a> 重写方法</h4> <p>派生类也可以重写基类的字段或者属性。你可以使用 <code>super.</code> 语法访问基类的方法。注意，由于 JavaScript 的类只是一个简单的查找对象，所以不存在“父类字段”的概念。</p> <p>TypeScript 强制认为派生类总是基类的一个子类。</p> <p>比如，下面是一个合法的重写方法的例子：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
  <span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Hello, world!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
  <span class="token function">greet</span><span class="token punctuation">(</span>name<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">const</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Derived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
d<span class="token punctuation">.</span><span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
d<span class="token punctuation">.</span><span class="token function">greet</span><span class="token punctuation">(</span><span class="token string">&quot;reader&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>很重要的一点是，派生类会遵循基类的约束。通过一个基类引用去引用一个派生类，是很常见（并且总是合法的！）的一种做法：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// 通过一个基类引用去命名一个派生类实例</span>
<span class="token keyword">const</span> b<span class="token operator">:</span> Base <span class="token operator">=</span> d<span class="token punctuation">;</span>
<span class="token comment">// 没有问题</span>
b<span class="token punctuation">.</span><span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>如果派生类 <code>Derived</code> 没有遵循基类 <code>Base</code> 的约束，会怎么样呢？</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
  <span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Hello, world!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
  <span class="token comment">// 让这个参数成为必选参数</span>
  <span class="token function">greet</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">^</span>  
<span class="token comment">/*
Property 'greet' in type 'Derived' is not assignable to the same property in base type 'Base'.
  Type '(name: string) =&gt; void' is not assignable to type '() =&gt; void'.
*/</span>  
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果无视错误并编译代码，那么下面的代码执行后会报错：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> b<span class="token operator">:</span> Base <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Derived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 因为 name 是 undefined，所以报错</span>
b<span class="token punctuation">.</span><span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="初始化顺序"><a href="#初始化顺序" class="header-anchor">#</a> 初始化顺序</h4> <p>JavaScript 类的初始化顺序在某些情况下可能会让你感到意外。我们看看下面的代码：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
  name <span class="token operator">=</span> <span class="token string">&quot;base&quot;</span><span class="token punctuation">;</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;My name is &quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
  name <span class="token operator">=</span> <span class="token string">&quot;derived&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token comment">// 打印 base 而不是 derived</span>
<span class="token keyword">const</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Derived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这里发生了什么事呢？</p> <p>根据 JavaScript 的定义，类初始化的顺序是：</p> <ul><li>初始化基类的字段</li> <li>执行基类的构造器</li> <li>初始化派生类的字段</li> <li>执行派生类的构造器</li></ul> <p>这意味着，因为基类构造器执行的时候派生类的字段尚未进行初始化，所以基类构造器只能看到自己的 <code>name</code> 值。</p> <h4 id="继承内置类型"><a href="#继承内置类型" class="header-anchor">#</a> 继承内置类型</h4> <blockquote><p>注意：如果你不打算继承诸如 Array、Error、Map 等内置类型，或者你的编译目标显式设置为 ES6/ES2015 或者更高的版本，那么你可以跳过这部分的内容。</p></blockquote> <p>在 ES2015 中，返回实例对象的构造器会隐式地将 <code>this</code> 的值替换为 <code>super(...)</code> 的任意调用者。有必要让生成的构造器代码捕获 <code>super(...)</code> 的任意潜在的返回值，并用 <code>this</code> 替换它。</p> <p>因此，<code>Error</code>、<code>Array</code> 等的子类可能无法如预期那样生效。这是因为诸如 <code>Error</code>、<code>Array</code> 这样的构造函数使用了 ES6 的 <code>new.target</code> 去调整原型链，但是，在 ES5 中调用构造器函数的时候，没有类似的方法可以确保 <code>new.target</code> 的值。默认情况下，其它底层编译器通常也具有相同的限制。</p> <p>对于一个像下面这样的子类：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">MsgError</span> <span class="token keyword">extends</span> <span class="token class-name">Error</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>m<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">&quot;hello &quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>你可能会发现：</p> <ul><li>调用子类之后返回的实例对象，其方法可能是 <code>undefined</code>，所以调用 <code>sayHello</code> 将会抛出错误</li> <li>子类实例和子类之间的 <code>instanceof</code> 可能被破坏，所以 <code>(new MsgError()) instanceof MsgError</code> 将会返回 <code>false</code>。</li></ul> <p>推荐的做法是，在任意的 <code>super(...)</code> 调用后面手动地调整原型链：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">MsgError</span> <span class="token keyword">extends</span> <span class="token class-name">Error</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>m<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 显式设置原型链</span>
    Object<span class="token punctuation">.</span><span class="token function">setPrototypeOf</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> MsgError<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
 
  <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">&quot;hello &quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>不过，<code>MsgError</code> 的任意子类也需要手动设置原型。对于不支持 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf" target="_blank" rel="noopener noreferrer">Object.setPrototypeOf<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的运行时，你可以改用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto" target="_blank" rel="noopener noreferrer"><code>__proto__</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>糟糕的是，<a href="https://msdn.microsoft.com/en-us/library/s4esdbwz(v=vs.94).aspx" target="_blank" rel="noopener noreferrer">这些变通方法在 IE10 或者更旧的版本上无法使用<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。你可以手动将原型上的方法复制到实例上（比如将 <code>MsgError.prototype</code> 的方法复制给 <code>this</code>），但原型链本身无法被修复。</p> <h2 id="成员可见性"><a href="#成员可见性" class="header-anchor">#</a> 成员可见性</h2> <p>你可以使用 TypeScript 控制特定的方法或属性是否在类的外面可见。</p> <h3 id="public"><a href="#public" class="header-anchor">#</a> <code>public</code></h3> <p>类成员的默认可见性是公有的（<code>public</code>）。公有成员随处可以访问：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">Greeter</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hi!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> g <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Greeter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
g<span class="token punctuation">.</span><span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>由于成员的可见性默认就是公有的，所以你不需要在类成员前面进行显式声明，但出于代码规范或者可读性的考虑，你也可以这么做。</p> <h3 id="protected"><a href="#protected" class="header-anchor">#</a> <code>protected</code></h3> <p>受保护（<code>protected</code>）成员只在类的子类中可见。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">Greeter</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Hello, &quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">protected</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">&quot;hi&quot;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">class</span> <span class="token class-name">SpecialGreeter</span> <span class="token keyword">extends</span> <span class="token class-name">Greeter</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token function">howdy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 这里可以访问受保护成员</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Howdy, &quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> g <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SpecialGreeter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
g<span class="token punctuation">.</span><span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK</span>
g<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token operator">^</span>
<span class="token comment">// Property 'getName' is protected and only accessible within class 'Greeter' and its subclasses.</span>
</code></pre></div><h4 id="公开受保护成员"><a href="#公开受保护成员" class="header-anchor">#</a> 公开受保护成员</h4> <p>派生类需要遵循其基类的约束，但可以选择公开具有更多功能的基类的子类。这包括了让受保护成员变成公有成员：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
    <span class="token keyword">protected</span> m <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
    <span class="token comment">// 没有修饰符，所以默认可见性是公有的</span>
    m <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dervied</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// OK</span>
</code></pre></div><p>注意 <code>Dervied</code> 已经可以自由读写成员 <code>m</code> 了，所以这么写并不会改变这种情况的“安全性”。这里需要注意的要点是，在派生类中，如果我们无意公开其成员，那么需要添加 <code>protected</code> 修饰符。</p> <h4 id="跨层级访问受保护成员"><a href="#跨层级访问受保护成员" class="header-anchor">#</a> 跨层级访问受保护成员</h4> <p>对于通过一个基类引用访问受保护成员是否合法，不同的 OOP 语言之间存在争议：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
    <span class="token keyword">protected</span> x<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Derived1</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
    <span class="token keyword">protected</span> x<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Derived2</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
    <span class="token function">f1</span><span class="token punctuation">(</span>other<span class="token operator">:</span> Derived2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        other<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">f2</span><span class="token punctuation">(</span>other<span class="token operator">:</span> Base<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        other<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
        	  <span class="token operator">^</span>
<span class="token comment">// Property 'x' is protected and only accessible through an instance of class 'Derived2'. This is an instance of class 'Base'.                  </span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>举个例子，Java 认为上述代码是合法的，但 C# 和 C++ 则认为上述代码是不合法的。</p> <p>TypeScript 也认为这是不合法的，因为只有在 <code>Derived2</code> 的子类中访问 <code>Derived2</code> 的 <code>x</code> 才是合法的，但 <code>Derived1</code> 并不是 <code>Derived2</code> 的子类。而且，如果通过 <code>Derived1</code> 引用访问 <code>x</code> 就已经是不合法的了（这确实应该是不合法的！），那么通过基类引用访问它也同样应该是不合法的。</p> <p>关于 C# 为什么会认为这段代码是不合法的，可以阅读这篇文章了解更多信息：<a href="https://blogs.msdn.microsoft.com/ericlippert/2005/11/09/why-cant-i-access-a-protected-member-from-a-derived-class/" target="_blank" rel="noopener noreferrer">为什么我无法在一个派生类中去访问一个受保护成员？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="private"><a href="#private" class="header-anchor">#</a> <code>private</code></h3> <p><code>private</code> 和 <code>protected</code> 一样，但声明了 <code>private</code> 的私有成员即使在子类中也无法被访问到：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 无法在类外面访问</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Property 'x' is private and only accessible within class 'Base'.</span>
<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
  <span class="token function">showX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 无法在子类中访问</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
      			    <span class="token operator">^</span>	
<span class="token comment">// Property 'x' is private and only accessible within class 'Base'.</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>由于私有成员对派生类不可见，所以派生类无法提高其可见性：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Dervied</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
<span class="token comment">/*
Class 'Derived' incorrectly extends base class 'Base'.
  Property 'x' is private in type 'Base' but not in type 'Derived'.    
*/</span>  
    x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="跨实例访问私有成员"><a href="#跨实例访问私有成员" class="header-anchor">#</a> 跨实例访问私有成员</h4> <p>对于同一个类的不同实例互相访问对方的私有成员是否合法，不同的 OOP 语言之间存在争议。Java、C#、C++、Swift 和 PHP 允许这么做，但 Ruby 则认为这样做是不合法的。</p> <p>TypeScript 允许跨实例访问私有成员：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token function">sameAs</span><span class="token punctuation">(</span>other<span class="token operator">:</span> <span class="token constant">A</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 不会报错</span>
        <span class="token keyword">return</span> other<span class="token punctuation">.</span>x <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="注意事项-2"><a href="#注意事项-2" class="header-anchor">#</a> 注意事项</h4> <p>和 TypeScript 类型系统中的其它东西一样，<code>private</code> 和 <code>protected</code> <a href="https://www.typescriptlang.org/play?removeComments=true&amp;target=99&amp;ts=4.3.4#code/PTAEGMBsEMGddAEQPYHNQBMCmVoCcsEAHPASwDdoAXLUAM1K0gwQFdZSA7dAKWkoDK4MkSoByBAGJQJLAwAeAWABQIUH0HDSoiTLKUaoUggAW+DHorUsAOlABJcQlhUy4KpACeoLJzrI8cCwMGxU1ABVPIiwhESpMZEJQTmR4lxFQaQxWMm4IZABbIlIYKlJkTlDlXHgkNFAAbxVQTIAjfABrAEEC5FZOeIBeUAAGAG5mmSw8WAroSFIqb2GAIjMiIk8VieVJ8Ar01ncAgAoASkaAXxVr3dUwGoQAYWpMHBgCYn1rekZmNg4eUi0Vi2icoBWJCsNBWoA6WE8AHcAiEwmBgTEtDovtDaMZQLM6PEoQZbA5wSk0q5SO4vD4-AEghZoJwLGYEIRwNBoqAzFRwCZCFUIlFMXECdSiAhId8YZgclx0PsiiVqOVOAAaUAFLAsxWgKiC35MFigfC0FKgSAVVDTSyk+W5dB4fplHVVR6gF7xJrKFotEk-HXIRE9PoDUDDcaTAPTWaceaLZYQlmoPBbHYx-KcQ7HPDnK43FQqfY5+IMDDISPJLCIuqoc47UsuUCofAME3Vzi1r3URvF5QV5A2STtPDdXqunZDgDaYlHnTDrrEAF0dm28B3mDZg6HJwN1+2-hg57ulwNV2NQGoZbjYfNrYiENBwEFaojFiZQK08C-4fFKTVCozWfTgfFgLkeT5AUqiAA" target="_blank" rel="noopener noreferrer">只在类型检查期间生效<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>这意味着 JavaScript 运行时的一些操作，诸如 <code>in</code> 或者简单的属性查找仍然可以访问私有成员或者受保护成员：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">MySafe</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> serectKey <span class="token operator">=</span> <span class="token number">123345</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 在 JavaScript 文件中会打印 12345</span>
<span class="token keyword">const</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MySafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>secretKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>而即使是在类型检查期间，我们也可以通过方括号语法去访问私有成员。因此，在进行诸如单元测试这样的操作时，访问私有字段会比较容易，但缺点就是这些字段是“弱私有的”，无法保证严格意义上的私有性。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">MySafe</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> secretKey <span class="token operator">=</span> <span class="token number">12345</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">const</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MySafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token comment">// 在类型检查期间，不允许这样访问私有成员</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>secretKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token operator">^</span>
<span class="token comment">// Property 'secretKey' is private and only accessible within class 'MySafe'.</span>
 
<span class="token comment">// 但是可以通过方括号语法访问</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token string">&quot;secretKey&quot;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>和 TypeScript 用 <code>private</code> 声明的私有成员不同，JavaScript 用 <code>#</code> 声明的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields" target="_blank" rel="noopener noreferrer">私有字段<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>在编译之后也仍然是私有的，并且没有提供像上面那样的方括号语法用于访问私有成员，所以 JavaScript 的私有成员是“强私有的”。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token punctuation">{</span>
    #barkAmount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    personality <span class="token operator">=</span> <span class="token string">'happy'</span><span class="token punctuation">;</span>
    
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>以下面这段 TypeScript 代码为例：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token punctuation">{</span>
    #barkAmount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    personality <span class="token operator">=</span> <span class="token string">&quot;happy&quot;</span><span class="token punctuation">;</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
</code></pre></div><p>把它编译为 ES2021 或者更低版本的代码之后，TypeScript 会使用 WeakMap 代替 <code>#</code>。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> _Dog_barkAmount<span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        _Dog_barkAmount<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>personality <span class="token operator">=</span> <span class="token string">&quot;happy&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
_Dog_barkAmount <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>如果你需要保护类中的值不被恶意修改，那么你应该使用提供了运行时私有性保障的机制，比如闭包、WeakMap 或者私有字段等。注意，这些在运行时添加的私有性检查可能会影响性能。</p> <h2 id="静态成员"><a href="#静态成员" class="header-anchor">#</a> 静态成员</h2> <blockquote><p>背景导读：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static" target="_blank" rel="noopener noreferrer">静态成员（MDN）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>类可以拥有静态（<code>static</code>）成员。这些成员和类的特定实例无关，我们可以通过类构造器对象本身访问到它们：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token function">printX</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>MyClass<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>MyClass<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
MyClass<span class="token punctuation">.</span><span class="token function">printX</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>静态成员也可以使用 <code>public</code>、<code>protected</code> 和 <code>private</code> 等可见性修饰符：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>MyClass<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
				  <span class="token operator">^</span>
<span class="token comment">// Property 'x' is private and only accessible within class 'MyClass'.           </span>
</code></pre></div><p>静态成员也可以被继承：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> <span class="token function">getGreeting</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">&quot;Hello world&quot;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
  myGreeting <span class="token operator">=</span> Derived<span class="token punctuation">.</span><span class="token function">getGreeting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="特殊的静态成员名字"><a href="#特殊的静态成员名字" class="header-anchor">#</a> 特殊的静态成员名字</h3> <p>重写 <code>Function</code> 原型的属性通常是不安全/不可能的。因为类本身也是一个可以通过 <code>new</code> 调用的函数，所以无法使用一些特定的静态成员名字。诸如 <code>name</code>、<code>length</code> 和 <code>call</code> 这样的函数属性无法作为静态成员的名字：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name"><span class="token constant">S</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> name <span class="token operator">=</span> <span class="token string">'S!'</span><span class="token punctuation">;</span>
    		<span class="token operator">^</span>
<span class="token comment">// Static property 'name' conflicts with built-in property 'Function.name' of constructor function 'S'.                </span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="为什么没有静态类"><a href="#为什么没有静态类" class="header-anchor">#</a> 为什么没有静态类？</h3> <p>TypeScript（和 JavaScript）并没有像 C# 和 Java 那样提供静态类这种结构。</p> <p>C# 和 Java 之所以需要静态类，是因为这些语言要求所有的数据和函数必须放在一个类中。因为在 TypeScirpt 中不存在这个限制，所以也就不需要静态类。只拥有单个实例的类在 JavaScript/TypeScirpt 中通常用一个普通对象表示。</p> <p>举个例子，在 TypeScript 中我们不需要“静态类”语法，因为一个常规的对象（甚至是顶层函数）也可以完成相同的工作：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// 不必要的静态类</span>
<span class="token keyword">class</span> <span class="token class-name">MyStaticClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 首选（方案一）</span>
<span class="token keyword">function</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">// 首选（方案二）</span>
<span class="token keyword">const</span> MyHelperObject <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">dosomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="类中的静态块"><a href="#类中的静态块" class="header-anchor">#</a> 类中的静态块</h2> <p>静态块允许你编写一系列声明语句，它们拥有自己的作用域，并且可以访问包含类中的私有字段。这意味着我们能够编写初始化代码，这些代码包含了声明语句，不会有变量泄漏的问题，并且完全可以访问类的内部。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> #count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">get</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> Foo<span class="token punctuation">.</span>#count<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
	<span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">const</span> lastInstances <span class="token operator">=</span> <span class="token function">loadLastInstances</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Foo<span class="token punctuation">.</span>#count <span class="token operator">+=</span> lastInstances<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">catch</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="泛型类"><a href="#泛型类" class="header-anchor">#</a> 泛型类</h2> <p>类和接口一样，也可以使用泛型。当用 <code>new</code> 实例化一个泛型类的时候，它的类型参数就像在函数调用中那样被推断出来：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">Box<span class="token operator">&lt;</span>Type<span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
    contents<span class="token operator">:</span> Type<span class="token punctuation">;</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span>value<span class="token operator">:</span> Type<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>contents <span class="token operator">=</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Box</span><span class="token punctuation">(</span><span class="token string">'hello!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	  <span class="token operator">^</span>	
    <span class="token comment">// const b: Box&lt;string&gt;      </span>
</code></pre></div><p>类可以像接口那样使用泛型约束和默认值。</p> <h3 id="静态成员中的类型参数"><a href="#静态成员中的类型参数" class="header-anchor">#</a> 静态成员中的类型参数</h3> <p>下面的代码是不合法的，但原因可能不那么明显：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">Box<span class="token operator">&lt;</span>Type<span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> defaultValue<span class="token operator">:</span> Type<span class="token punctuation">;</span>
    					<span class="token operator">^</span>
<span class="token comment">//  Static members cannot reference class type parameters.                       </span>
<span class="token punctuation">}</span>
</code></pre></div><p>记住，类型在编译后总是会被完全抹除的！在运行时，只有一个 <code>Box.defaultValue</code> 属性插槽。这意味着设置 <code>Box&lt;string&gt;.defaultValue</code>（如果可以设置的话）也会改变 <code>Box&lt;number&gt;.defaultValue</code> —— 这是不行的。泛型类的静态成员永远都不能引用类的类型参数。</p> <h2 id="类的运行时-this"><a href="#类的运行时-this" class="header-anchor">#</a> 类的运行时 <code>this</code></h2> <p>有个要点需要记住，那就是 TypeScript 不会改变 JavaScript 的运行时行为。而众所周知，JavaScript 拥有一些特殊的运行时行为。</p> <p>JavaScript 对于 <code>this</code> 的处理确实是很不寻常：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span>
  name <span class="token operator">=</span> <span class="token string">&quot;MyClass&quot;</span><span class="token punctuation">;</span>
  <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;obj&quot;</span><span class="token punctuation">,</span>
  getName<span class="token operator">:</span> c<span class="token punctuation">.</span>getName<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
 
<span class="token comment">// 打印 &quot;obj&quot; 而不是 &quot;MyClass&quot;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>长话短说，默认情况下，函数中 <code>this</code> 的值取决于<strong>函数是如何被调用的</strong>。在这个例子中，由于我们通过 <code>obj</code> 引用去调用函数，所以它的 <code>this</code> 的值是 <code>obj</code>，而不是类实例。</p> <p>这通常不是我们期望的结果！TypeScript 提供了一些方法让我们可以减少或者防止这种错误的发生。</p> <h3 id="箭头函数"><a href="#箭头函数" class="header-anchor">#</a> 箭头函数</h3> <p>如果你的函数在被调用的时候经常会丢失 <code>this</code> 上下文，那么最好使用箭头函数属性，而不是方法定义：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span>
    name <span class="token operator">=</span> <span class="token string">'MyClass'</span><span class="token punctuation">;</span>
    <span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> g <span class="token operator">=</span> c<span class="token punctuation">.</span>getName<span class="token punctuation">;</span>
<span class="token comment">// 打印 MyClass </span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这种做法有一些利弊权衡：</p> <ul><li>在运行时可以保证 <code>this</code> 的值是正确的，即使对于那些没有使用 TypeScript 进行检查的代码也是如此</li> <li>这样会占用更多内存，因为以这种方式定义的函数，会导致每个类实例都有一份函数副本</li> <li>你无法在派生类中使用 <code>super.getName</code>，因为在原型链上没有入口可以去获取基类的方法</li></ul> <h3 id="this-参数"><a href="#this-参数" class="header-anchor">#</a> <code>this</code> 参数</h3> <p>在 TypeScript 的方法或者函数定义中，第一个参数的名字如果是 <code>this</code>，那么它有特殊的含义。这样的参数在编译期间会被抹除：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// TypeScript 接受 this 参数</span>
<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">:</span> SomeType<span class="token punctuation">,</span> x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span>
<span class="token comment">// 输出得 JavaScript </span>
<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span>
</code></pre></div><p>TypeScript 会检查传入 <code>this</code> 参数的函数调用是否位于正确的上下文中。这里我们没有使用箭头函数，而是给方法定义添加了一个 <code>this</code> 参数，以静态的方式确保方法可以被正确调用：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span>
  name <span class="token operator">=</span> <span class="token string">&quot;MyClass&quot;</span><span class="token punctuation">;</span>
  <span class="token function">getName</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">:</span> MyClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// OK</span>
c<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token comment">// 报错</span>
<span class="token keyword">const</span> g <span class="token operator">=</span> c<span class="token punctuation">.</span>getName<span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// The 'this' context of type 'void' is not assignable to method's 'this' of type 'MyClass'.</span>
</code></pre></div><p>这种方法的利弊权衡和上面使用箭头函数的方法相反：</p> <ul><li>JavaScript 的调用方可能仍然会在没有意识的情况下错误地调用类方法</li> <li>只会给每个类定义分配一个函数，而不是给每个类实例分配一个函数</li> <li>仍然可以通过 <code>super</code> 调用基类定义的方法</li></ul> <h2 id="this-类型"><a href="#this-类型" class="header-anchor">#</a> <code>this</code> 类型</h2> <p>在类中，名为 <code>this</code> 的特殊类型可以动态地引用当前类的类型。我们看一下它是怎么发挥作用的：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">Box</span> <span class="token punctuation">{</span>
    contents<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>
    <span class="token function">set</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token operator">^</span>
    <span class="token comment">// (method) Box.set(value: string): this</span>
         <span class="token keyword">this</span><span class="token punctuation">.</span>contents <span class="token operator">=</span> value<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里，TypeScript 将 <code>set</code> 的返回值类型推断为 <code>this</code>，而不是 <code>Box</code>。现在我们来创建一个 <code>Box</code> 的子类：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">ClearableBox</span> <span class="token keyword">extends</span> <span class="token class-name">Box</span> <span class="token punctuation">{</span>
    <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>contents <span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClearableBox</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> b <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token operator">^</span>
<span class="token comment">// const b: ClearableBox</span>
</code></pre></div><p>你也可以在参数的类型注解中使用 <code>this</code>：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">Box</span> <span class="token punctuation">{</span>
  content<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>
  <span class="token function">sameAs</span><span class="token punctuation">(</span>other<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> other<span class="token punctuation">.</span>content <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>content<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这和使用 <code>other: Box</code> 是不一样的 —— 如果你有一个派生类，那么它的 <code>sameAs</code> 方法将只会接受该派生类的其它实例：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">Box</span> <span class="token punctuation">{</span>
  content<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>
  <span class="token function">sameAs</span><span class="token punctuation">(</span>other<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> other<span class="token punctuation">.</span>content <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>content<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">class</span> <span class="token class-name">DerivedBox</span> <span class="token keyword">extends</span> <span class="token class-name">Box</span> <span class="token punctuation">{</span>
  otherContent<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">&quot;?&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">const</span> base <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Box</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> derived <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DerivedBox</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
derived<span class="token punctuation">.</span><span class="token function">sameAs</span><span class="token punctuation">(</span>base<span class="token punctuation">)</span><span class="token punctuation">;</span>
			    <span class="token operator">^</span>
<span class="token comment">/*
Argument of type 'Box' is not assignable to parameter of type 'DerivedBox'.
  Property 'otherContent' is missing in type 'Box' but required in type 'DerivedBox'.
*/</span>  
</code></pre></div><h3 id="基于-this-的类型保护"><a href="#基于-this-的类型保护" class="header-anchor">#</a> 基于 <code>this</code> 的类型保护</h3> <p>你可以在类和接口的方法的返回值类型注解处使用 <code>this is Type</code>。该语句和类型收缩（比如说 <code>if</code> 语句）一起使用的时候，目标对象的类型会被收缩为指定的 <code>Type</code>。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">FileSystemObject</span> <span class="token punctuation">{</span>
  <span class="token function">isFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">this</span> <span class="token keyword">is</span> FileRep <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">FileRep</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">isDirectory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">this</span> <span class="token keyword">is</span> Directory <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">Directory</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">isNetworked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">this</span> <span class="token keyword">is</span> Networked <span class="token operator">&amp;</span> <span class="token keyword">this</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>networked<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">public</span> path<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token keyword">private</span> networked<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">class</span> <span class="token class-name">FileRep</span> <span class="token keyword">extends</span> <span class="token class-name">FileSystemObject</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>path<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token keyword">public</span> content<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">class</span> <span class="token class-name">Directory</span> <span class="token keyword">extends</span> <span class="token class-name">FileSystemObject</span> <span class="token punctuation">{</span>
  children<span class="token operator">:</span> FileSystemObject<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">interface</span> <span class="token class-name">Networked</span> <span class="token punctuation">{</span>
  host<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">const</span> fso<span class="token operator">:</span> FileSystemObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileRep</span><span class="token punctuation">(</span><span class="token string">&quot;foo/bar.txt&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token keyword">if</span> <span class="token punctuation">(</span>fso<span class="token punctuation">.</span><span class="token function">isFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  fso<span class="token punctuation">.</span>content<span class="token punctuation">;</span>
   <span class="token operator">^</span>
 <span class="token comment">// const fso: FileRep</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>fso<span class="token punctuation">.</span><span class="token function">isDirectory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  fso<span class="token punctuation">.</span>children<span class="token punctuation">;</span>
   <span class="token operator">^</span> 
 <span class="token comment">// const fso: Directory</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>fso<span class="token punctuation">.</span><span class="token function">isNetworked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  fso<span class="token punctuation">.</span>host<span class="token punctuation">;</span>
   <span class="token operator">^</span> 
 <span class="token comment">// const fso: Networked &amp; FileSystemObject</span>
<span class="token punctuation">}</span>
</code></pre></div><p>基于 <code>this</code> 的类型保护的常见用例是允许特定字段的延迟验证。以下面的代码为例，当 <code>hasValue</code> 被验证为 true 的时候，可以移除 <code>Box</code> 中为 <code>undefined</code> 的 <code>value</code> 值：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">Box<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
  value<span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
 
  <span class="token function">hasValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">this</span> <span class="token keyword">is</span> <span class="token punctuation">{</span> value<span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">}</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">const</span> box <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Box</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
box<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token string">&quot;Gameboy&quot;</span><span class="token punctuation">;</span>
 
box<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
      <span class="token operator">^</span>
    <span class="token comment">// (property) Box&lt;unknown&gt;.value?: unknown</span>
 
<span class="token keyword">if</span> <span class="token punctuation">(</span>box<span class="token punctuation">.</span><span class="token function">hasValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  box<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
        <span class="token operator">^</span>   
   <span class="token comment">// (property) value: unknown</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="参数属性"><a href="#参数属性" class="header-anchor">#</a> 参数属性</h2> <p>TypeScript 提供了一种特殊的语法，可以将构造器参数转化为具有相同名字和值的类属性。这种语法叫做参数属性，实现方式是在构造器参数前面加上 <code>public</code>、<code>private</code>、<code>protected</code> 或者 <code>readonly</code> 等其中一种可见性修饰符作为前缀。最终的字段将会获得这些修饰符：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">Params</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span>
        <span class="token keyword">public</span> <span class="token keyword">readonly</span> x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span>
        <span class="token keyword">protected</span> y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span>
        <span class="token keyword">private</span> z<span class="token operator">:</span> <span class="token builtin">number</span>    
    <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 没有必要编写构造器的函数体     </span>
    <span class="token punctuation">}</span>    
<span class="token punctuation">}</span>
<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Params</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
			 <span class="token operator">^</span>
            <span class="token comment">// (property) Params.x: number</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span>
			 <span class="token operator">^</span>
<span class="token comment">// Property 'z' is private and only accessible within class 'Params'.           </span>
</code></pre></div><h2 id="类表达式"><a href="#类表达式" class="header-anchor">#</a> 类表达式</h2> <blockquote><p>背景导读：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/class" target="_blank" rel="noopener noreferrer">类表达式（MDN）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>类表达式和类声明非常相似。唯一的不同在于，类表达式不需要名字，但我们仍然可以通过任意绑定给类表达式的标识符去引用它们：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> someClass <span class="token operator">=</span> <span class="token keyword">class</span><span class="token operator">&lt;</span>Type<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    content<span class="token operator">:</span> Type<span class="token punctuation">;</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span>value<span class="token operator">:</span> Type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>content <span class="token operator">=</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">someClass</span><span class="token punctuation">(</span><span class="token string">&quot;Hello, world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	  <span class="token operator">^</span>
    <span class="token comment">// const m: someClass&lt;string&gt;      </span>
</code></pre></div><h2 id="抽象类和成员"><a href="#抽象类和成员" class="header-anchor">#</a> 抽象类和成员</h2> <p>在 TypeScript 中，类、方法和字段可能是抽象的。</p> <p>抽象方法或者抽象字段在类中没有对应的实现。这些成员必须存在于一个无法直接被实例化的抽象类中。</p> <p>抽象类的角色是充当一个基类，让其子类去实现所有的抽象成员。当一个类没有任何抽象成员的时候，我们就说它是具体的。</p> <p>来看一个例子：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
    <span class="token keyword">abstract</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
    <span class="token function">printName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Hello, &quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Cannot create an instance of an abstract class.</span>
</code></pre></div><p>因为 <code>Base</code> 是一个抽象类，所以我们不能使用 <code>new</code> 去实例化它。相反地，我们需要创建一个派生类，让它去实现抽象成员：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
    <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        rteurn <span class="token string">&quot;world&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Derived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
d<span class="token punctuation">.</span><span class="token function">printName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>注意，如果我们忘记实现基类的抽象成员，那么会抛出一个错误：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
    	<span class="token operator">^</span>
<span class="token comment">// Non-abstract class 'Derived' does not implement inherited abstract member 'getName' from class 'Base'.</span>
  <span class="token comment">// 忘记实现抽象成员</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="抽象构造签名"><a href="#抽象构造签名" class="header-anchor">#</a> 抽象构造签名</h3> <p>有时候你想要接受一个类构造器函数作为参数，让它产生某个类的实例，并且这个类是从某个抽象类派生过来的。</p> <p>举个例子，你可能想要编写下面这样的代码：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">greet</span><span class="token punctuation">(</span>ctor<span class="token operator">:</span> <span class="token keyword">typeof</span> Base<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Cannot create an instance of an abstract class.</span>
  instance<span class="token punctuation">.</span><span class="token function">printName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>TypeScript 会正确地告诉你，你正试图实例化一个抽象类。毕竟，根据 <code>greet</code> 的定义，编写这样的代码理应是完全合法的，它最终会构造一个抽象类的实例：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// 不行！</span>
<span class="token function">greet</span><span class="token punctuation">(</span>Base<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>但它实际上会报错。所以，你编写的函数所接受的参数应该带有一个构造签名：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">greet</span><span class="token punctuation">(</span>ctor<span class="token operator">:</span> <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Base<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  instance<span class="token punctuation">.</span><span class="token function">printName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">greet</span><span class="token punctuation">(</span>Derived<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">greet</span><span class="token punctuation">(</span>Base<span class="token punctuation">)</span><span class="token punctuation">;</span>
	   <span class="token operator">^</span>	
<span class="token comment">/*
Argument of type 'typeof Base' is not assignable to parameter of type 'new () =&gt; Base'.
  Cannot assign an abstract constructor type to a non-abstract constructor type.
*/</span>  
</code></pre></div><p>现在 TypeScript 可以正确地告知你哪个类构造器函数可以被调用了 —— <code>Derived</code> 可以被调用，因为它是一个具体类，而 <code>Base</code> 不能被调用，因为它是一个抽象类。</p> <h2 id="类之间的联系"><a href="#类之间的联系" class="header-anchor">#</a> 类之间的联系</h2> <p>在大多数情况下，TypeScript 中的类是在结构上进行比较的，就跟其它类型一样。</p> <p>举个例子，下面这两个类可以互相替代对方，因为它们在结构上是一模一样的：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">Point1</span> <span class="token punctuation">{</span>
  x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">class</span> <span class="token class-name">Point2</span> <span class="token punctuation">{</span>
  x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token comment">// OK</span>
<span class="token keyword">const</span> p<span class="token operator">:</span> Point1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>类似地，即使没有显式声明继承关系，类和类之间也可以存在子类联系：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  salary<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token comment">// OK</span>
<span class="token keyword">const</span> p<span class="token operator">:</span> Person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这听起来很简单易懂，但还有一些情况会比较奇怪。</p> <p>空类没有成员。在一个结构化的类型系统中，一个没有成员的类型通常是任何其它类型的超类。所以如果你编写了一个空类（不要这么做！），那么你可以用任何类型去替代它：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">Empty</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>x<span class="token operator">:</span> Empty<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 无法对 x 执行任何操作，所以不建议这么写</span>
<span class="token punctuation">}</span>

<span class="token comment">// 这些参数都是可以传入的！</span>
<span class="token function">fn</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">fn</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></div></section> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/Vuepress-TypeScriptDoc/Handbook/TypeManipulation/TemplateLiteralTypes.html" class="prev">
            模板字面量类型
          </a></span> <span class="next"><a href="/Vuepress-TypeScriptDoc/Handbook/Modules.html">
            模块
          </a></span></p></div> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-cb1513f6><li class="level-2" data-v-cb1513f6><a href="/Vuepress-TypeScriptDoc/Handbook/Classes.html#类成员" class="sidebar-link reco-side-类成员" data-v-cb1513f6>类成员</a></li><li class="level-3" data-v-cb1513f6><a href="/Vuepress-TypeScriptDoc/Handbook/Classes.html#字段" class="sidebar-link reco-side-字段" data-v-cb1513f6>字段</a></li><li class="level-3" data-v-cb1513f6><a href="/Vuepress-TypeScriptDoc/Handbook/Classes.html#readonly" class="sidebar-link reco-side-readonly" data-v-cb1513f6>readonly</a></li><li class="level-3" data-v-cb1513f6><a href="/Vuepress-TypeScriptDoc/Handbook/Classes.html#构造器" class="sidebar-link reco-side-构造器" data-v-cb1513f6>构造器</a></li><li class="level-3" data-v-cb1513f6><a href="/Vuepress-TypeScriptDoc/Handbook/Classes.html#方法" class="sidebar-link reco-side-方法" data-v-cb1513f6>方法</a></li><li class="level-3" data-v-cb1513f6><a href="/Vuepress-TypeScriptDoc/Handbook/Classes.html#getters-setters" class="sidebar-link reco-side-getters-setters" data-v-cb1513f6>Getters/Setters</a></li><li class="level-3" data-v-cb1513f6><a href="/Vuepress-TypeScriptDoc/Handbook/Classes.html#索引签名" class="sidebar-link reco-side-索引签名" data-v-cb1513f6>索引签名</a></li><li class="level-2" data-v-cb1513f6><a href="/Vuepress-TypeScriptDoc/Handbook/Classes.html#类继承" class="sidebar-link reco-side-类继承" data-v-cb1513f6>类继承</a></li><li class="level-3" data-v-cb1513f6><a href="/Vuepress-TypeScriptDoc/Handbook/Classes.html#implements-子句" class="sidebar-link reco-side-implements-子句" data-v-cb1513f6>implements 子句</a></li><li class="level-3" data-v-cb1513f6><a href="/Vuepress-TypeScriptDoc/Handbook/Classes.html#extends-子句" class="sidebar-link reco-side-extends-子句" data-v-cb1513f6>extends 子句</a></li><li class="level-2" data-v-cb1513f6><a href="/Vuepress-TypeScriptDoc/Handbook/Classes.html#成员可见性" class="sidebar-link reco-side-成员可见性" data-v-cb1513f6>成员可见性</a></li><li class="level-3" data-v-cb1513f6><a href="/Vuepress-TypeScriptDoc/Handbook/Classes.html#public" class="sidebar-link reco-side-public" data-v-cb1513f6>public</a></li><li class="level-3" data-v-cb1513f6><a href="/Vuepress-TypeScriptDoc/Handbook/Classes.html#protected" class="sidebar-link reco-side-protected" data-v-cb1513f6>protected</a></li><li class="level-3" data-v-cb1513f6><a href="/Vuepress-TypeScriptDoc/Handbook/Classes.html#private" class="sidebar-link reco-side-private" data-v-cb1513f6>private</a></li><li class="level-2" data-v-cb1513f6><a href="/Vuepress-TypeScriptDoc/Handbook/Classes.html#静态成员" class="sidebar-link reco-side-静态成员" data-v-cb1513f6>静态成员</a></li><li class="level-3" data-v-cb1513f6><a href="/Vuepress-TypeScriptDoc/Handbook/Classes.html#特殊的静态成员名字" class="sidebar-link reco-side-特殊的静态成员名字" data-v-cb1513f6>特殊的静态成员名字</a></li><li class="level-3" data-v-cb1513f6><a href="/Vuepress-TypeScriptDoc/Handbook/Classes.html#为什么没有静态类" class="sidebar-link reco-side-为什么没有静态类" data-v-cb1513f6>为什么没有静态类？</a></li><li class="level-2" data-v-cb1513f6><a href="/Vuepress-TypeScriptDoc/Handbook/Classes.html#类中的静态块" class="sidebar-link reco-side-类中的静态块" data-v-cb1513f6>类中的静态块</a></li><li class="level-2" data-v-cb1513f6><a href="/Vuepress-TypeScriptDoc/Handbook/Classes.html#泛型类" class="sidebar-link reco-side-泛型类" data-v-cb1513f6>泛型类</a></li><li class="level-3" data-v-cb1513f6><a href="/Vuepress-TypeScriptDoc/Handbook/Classes.html#静态成员中的类型参数" class="sidebar-link reco-side-静态成员中的类型参数" data-v-cb1513f6>静态成员中的类型参数</a></li><li class="level-2" data-v-cb1513f6><a href="/Vuepress-TypeScriptDoc/Handbook/Classes.html#类的运行时-this" class="sidebar-link reco-side-类的运行时-this" data-v-cb1513f6>类的运行时 this</a></li><li class="level-3" data-v-cb1513f6><a href="/Vuepress-TypeScriptDoc/Handbook/Classes.html#箭头函数" class="sidebar-link reco-side-箭头函数" data-v-cb1513f6>箭头函数</a></li><li class="level-3" data-v-cb1513f6><a href="/Vuepress-TypeScriptDoc/Handbook/Classes.html#this-参数" class="sidebar-link reco-side-this-参数" data-v-cb1513f6>this 参数</a></li><li class="level-2" data-v-cb1513f6><a href="/Vuepress-TypeScriptDoc/Handbook/Classes.html#this-类型" class="sidebar-link reco-side-this-类型" data-v-cb1513f6>this 类型</a></li><li class="level-3" data-v-cb1513f6><a href="/Vuepress-TypeScriptDoc/Handbook/Classes.html#基于-this-的类型保护" class="sidebar-link reco-side-基于-this-的类型保护" data-v-cb1513f6>基于 this 的类型保护</a></li><li class="level-2" data-v-cb1513f6><a href="/Vuepress-TypeScriptDoc/Handbook/Classes.html#参数属性" class="sidebar-link reco-side-参数属性" data-v-cb1513f6>参数属性</a></li><li class="level-2" data-v-cb1513f6><a href="/Vuepress-TypeScriptDoc/Handbook/Classes.html#类表达式" class="sidebar-link reco-side-类表达式" data-v-cb1513f6>类表达式</a></li><li class="level-2" data-v-cb1513f6><a href="/Vuepress-TypeScriptDoc/Handbook/Classes.html#抽象类和成员" class="sidebar-link reco-side-抽象类和成员" data-v-cb1513f6>抽象类和成员</a></li><li class="level-3" data-v-cb1513f6><a href="/Vuepress-TypeScriptDoc/Handbook/Classes.html#抽象构造签名" class="sidebar-link reco-side-抽象构造签名" data-v-cb1513f6>抽象构造签名</a></li><li class="level-2" data-v-cb1513f6><a href="/Vuepress-TypeScriptDoc/Handbook/Classes.html#类之间的联系" class="sidebar-link reco-side-类之间的联系" data-v-cb1513f6>类之间的联系</a></li></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/Vuepress-TypeScriptDoc/assets/js/app.9c3a9755.js" defer></script><script src="/Vuepress-TypeScriptDoc/assets/js/3.cc39fa8f.js" defer></script><script src="/Vuepress-TypeScriptDoc/assets/js/1.145ed21b.js" defer></script><script src="/Vuepress-TypeScriptDoc/assets/js/10.df955495.js" defer></script>
  </body>
</html>
