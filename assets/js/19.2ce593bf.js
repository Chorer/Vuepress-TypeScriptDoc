(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{559:function(e,t,p){"use strict";p.r(t);var v=p(12),_=Object(v.a)({},(function(){var e=this,t=e.$createElement,p=e._self._c||t;return p("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[p("p",[e._v("TypeScript 的类型系统非常强大，因为它允许我们用其它类型去表示新的类型。")]),e._v(" "),p("p",[e._v("最简单的方式就是使用泛型，我们实际上有多种类型的操作符可以使用。此外，也可以用已有的值去表示类型。")]),e._v(" "),p("p",[e._v("通过结合不同的类型操作符，我们可以用一种简洁、可维护的方式去表示复杂的操作或者值。在本章节中，我们将会讲解几种用已有的类型或值表示新类型的方法。")]),e._v(" "),p("ul",[p("li",[p("p",[p("a",{attrs:{href:"./Generics"}},[e._v("泛型")]),e._v(" —— 可以接受参数的类型")])]),e._v(" "),p("li",[p("p",[p("a",{attrs:{href:"./KeyofTypeOperator"}},[e._v("Keyof 类型操作符")]),e._v(" —— 使用 "),p("code",[e._v("keyof")]),e._v(" 操作符创建新类型")])]),e._v(" "),p("li",[p("p",[p("a",{attrs:{href:"./TypeofTypeOperator"}},[e._v("Typeof 类型操作符")]),e._v(" —— 使用 "),p("code",[e._v("typeof")]),e._v(" 操作符创建新类型")])]),e._v(" "),p("li",[p("p",[p("a",{attrs:{href:"./IndexedAccessTypes"}},[e._v("按索引访问类型")]),e._v(" —— 使用 "),p("code",[e._v("Type['a']")]),e._v(" 语法访问某个类型的某个子集")])]),e._v(" "),p("li",[p("p",[p("a",{attrs:{href:"./ConditionalTypes"}},[e._v("条件类型")]),e._v(" —— 该类型的行为类似于类型系统中的 if 语句")])]),e._v(" "),p("li",[p("p",[p("a",{attrs:{href:"./MappedTypes"}},[e._v("映射类型")]),e._v(" —— 通过映射已有类型的每个属性去创建类型")])]),e._v(" "),p("li",[p("p",[p("a",{attrs:{href:"./TemplateLiteralTypes"}},[e._v("模板字面量类型")]),e._v(" —— 通过模板字面量字符串改变属性的映射类型")])])])])}),[],!1,null,null,null);t.default=_.exports}}]);